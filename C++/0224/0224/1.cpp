#include <iostream>

using namespace std;

void main()
{
	//자료형의 종류
	/*
	크기 별
	1byte = char(문자), bool(논리)
	2byte = short(정수형) 65535 
	4byte = int, long 비표준, float 2^32 42억 1 바이트 = 8비트 = 2^8 
	8byte = long long, double , long double 2^64제곱

	데이터별
	문자자료형
	char(아스키 코드에 각 문자별로 정수가 정해져 있어 값 자체는 정수값)
	
	논리자료형
	bool (출력값은 참이면 1 거짓이면 0을 출력한다.)
	
	정수자료형
	short, int, long, long long

	정수 표현 방식에는 signed와 unsigned 로 표현된다. (부호가 있냐, 없냐) defalut값은 signed 값.
	unsigned는 음수 값 없이 양수 값만 표현
	signed는 음수 범위까지 포함. unsigned 값의 절반을 음수로 표시.
	비트 중 제일 왼쪽 비트를 0이면 양수만 1이면 음수로 표시하는 것으로 음수,양수 구분. 비트 하나를 부호비트로 쓰기에 표시 가능한 수가 절반이 된다.
	양의정수의 비트를 2의 보수하는 것이 음의 정수 표현 방식이다
	보수-비트반전, 2의보수 - 비트반전 후 1을 더하는 건
	0001 -> 1110 -> 1111(2의 보수가 된 -1)
	0001 + 1111 = 0000 으로 0이 된다.
	
	실수자료형
	float doulbe long double
	
	실수 같은 경우는 부동(둥둥 떠다닌다.) 소수점 벙삭울 취한다. 비트 공간을 둘로 나누고 반은 정수, 반은 소수 파트로 사용한다. 그 구분점을 유동적으로 선택
	다만 이 방식으로 인해 오차가 발생.
	*/

	char ch = 65; //대문자 A 의 아스키코드 값.
	char ch1 = 'A'; // 이런 식으로 표현해도 위와 동일하다.

	cout << ch << endl;

	bool b = true;
	bool b1 = 0.00001f; //이런 식으로 값을 입력해도 0이면 false, 0이 아닌 모든 수를 true로 받아들인다. 

	cout << b1 << endl;

	short n = 10;
	n = 32768;//short 최대 범위를 벗어나니 최소값인 -32768이 된다.

	cout << n << endl;

	float f = 10.f; //리터널 상수와 임시 메모리.
	//연산을 하기 위해선 메모리에 올라가 있어야 한다. 리터널 상수는 메모리 공간에 올라가 있는 게 아니다. 담아둘 이유가 없다.
	//연산을 할 때 임시 메모리 공간에 리터널 상수를 올린다. 해당 코드 라인에서만 잠깐 생성되었다가 소멸.
	//double 실수 디폴트인 이유는 4바이트 크기로 할 경우 낮은 소수점의 정보가 손실될 수 있기 때문이다.
	//임시 메모리를 잡을 때 정수는 int 형 4바이트 실수는 double 8바이트로 잡는다. f를 붙이는 이유는 디폴트 값 말고 float(4바이트) 형식으로 잡아달라 요청하는 것,
	//심볼릭 상수.
	//변수를 상수화 시키는 것. 알파벳 a가 어디서든 알파벳 a인 것처럼 특정 변수를 값 하나로 고정시키는 행위
	//const int 등으로 쓰이며 선언과 동시에 초기화가 되어야 하며 추후 다른 코드에서 해당 변수의 값을 수정할 수 없도록 한다.
	//예를 들어 const double Pi =3.141592; 와 같이 값이 일정하게 변동없이 유지되기를 바라는 경우 사용한다. 이러한 방식을 취하면 다른 코드에서 수정 및 값에 영향을 주지 못한다.

	const double remember = 3.14;
	//remember +=1 과 같이 다른 줄에서 해당 변수에 영향을 줄 수가 없게 된다.
	cout<< remember  << endl;

	float f = 10.f;



}	