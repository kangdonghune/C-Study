// 0329_생성자.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"
#include "Monster.h"

class CConstractor
{
	//생성자는 최초 단 한 번 호출되는 함수.
	//객체가 생성될 때 자동 생성되소 호출되는 4가지 중 하나.
	//기본 생성자 없으면 자동 생성 후 호출
	//생성자는 클래스명과 동일
	//반환 타입은 없다.
public:
	explicit CConstractor()
	{
		cout << "기본 생성자 호출" << endl;
	}
	explicit CConstractor(int a) //묵시적 형변환을 막아주는 키워드.= c스타일 초기화 방지.
	{

	}
	//사용자가 생성자를 정의할 경우 더이상 디폴트 생성자를 자동 생성하지 않는다.
	//그러니 오버로딩한 생성자를 작성 시 기본 생성자도 작성을 해주자.
	//생성자는 오버로딩이 늘어남에 따라 경우에 따라 초기화가 될 수도, 안 될 수도 있다는 문제가 있다.
	//그러니 취향에 따라 확실하게 초기화하기 위해 초기화 함수 자체를 따로 만들어 두고 확실하게 초기화하기도 한다.

	//소멸자. 객체가 소멸될 떄 호출되는 함수. ~로 표시. 모습 자체는 생성자와 유사. 다만 차이점은 오버로딩 불가.
	//할당한 데이터가 있다면 소멸자를 활용해서 해제할 수 있다.
	//~CConstractor() = default; 로 쓰면
	//~CConstractor() {} 로 쓰겠다는 뜻.
	//소멸자도 객체 생성 시 자동 생성되고 호출되는 함수. 별도 생성 안 할 시 기본 소멸자 생성하고 호출함.
	~CConstractor()
	{
		cout << "소멸자 호출" << endl;
	}

};

/*전방선언.
class 끼리 다른 class를 멤버로 가질 때 위에서부터 아래로 컴파일러가 읽기 떄문에 순서에 따라 오류가 발생.
이를 방지하고 위해 함수처럼 선언부만 위로 올리는 것.
전방 선언을 안 하면 파일분리를 해둔 클래스의 경우 메모리 크기 측정을 위해 각자의 파일의 상호 참조하다가 데드락이 발생한다.
상호 참조가 발생할 수 있으니 헤더에 헤더를 추가하지 말고 전방선언을 하자.
*/

//class CPlayer;
//
//class CMonster
//{
//
//	//CPlayer m_tPlayer; //이렇게 하면 위에서 선언이 되어 있어도 CPlayer 자체의 크기는 알 수가 없다. 그러니 멤버로 가질 수가 없다.
//	CPlayer* m_tPlayer;//그래서 포인터 형식으로 하면 포인터는 4바이트 동일이기에 멤버로 만들 수 있다.
//};
//class CPlayer
//{
//
//};

int main()
{
	CConstractor tconstrator;
	//CConstractor tconstrator = 10; //c스타일 생성자. CConstractor(10); 으로 컴퓨터가 인식.
	//CConstractor tconstrator1(10); //c++ 스타일

	CMonster tM;
	tM.Test();
    return 0;

	//객체를 선언->메모리 할당->생성자 호출 -> 소멸자가 호출 ->메모리 해제 -> 소멸
}

