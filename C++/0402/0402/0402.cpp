// 0402.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"

class C_Obj
{
public:
	//virtual 일반 멤버 함수가 아니라 가상 함수가 된다. 가상 함수란 호출하는 객체의 실제 타입으로 접근해 해당 객체의 함수를 사용한다.
	virtual void Render()
	{
		cout << "부모 랜더 함수" << endl;
	}

	virtual void Requiredfunction() = 0; //순수 가상 함수. 선언시 해당 클래스 추상 클래스 화 객체 생성 불가.
};

class CPlayer : public C_Obj
{
public:
	virtual void Render()
	//함수 오바라이딩. 클래스 문법. 부모에 함수가 정의되어 있는 상태에서 부모의 함수를 아예 똑같이 재정의 하는 문법(반환타입 이름 매개변수 개수 타입)까지 똑같이 하는 거.
	//부모의 함수는 자식에서 오버라이딩된 함수 호출 시 순위가 밀려서 호출 되지 않는다.
	//다형성을 위해 자주 쓰인다. 부모에선 개념적인 함수만 만들어두고 자식에서 개념적인 함수를 가져다가 구체적으로 정의
	//만약 실제 객체를 기준으로 오버 라이딩 된 함수를 호출하고 싶으면 virtual을 붙여라. 그리고 virtual을 부모에 붙이면 자식에게도 물려지기에 자식 오버라이딩에는 안 붙여도 되지만 명시적으로 붙여주자.
	{
		cout << "자식 랜더 함수" << endl;
	}

	virtual void Requiredfunction() //순수 가상 함수는 재정의해주지 않을 시 에러 발생.
	{
		cout << "자식에서 반드시 재정의 해줘야 한다." << endl;
	}

	void LevelUp()
	{
		cout << "lever up" << endl;
	}
};

class CUnit : public CPlayer
{
public:
	//virtual 일반 멤버 함수가 아니라 가상 함수가 된다.
	void Render()
	{
		cout << "손자 랜더 함수" << endl;
		//부모 호출 원할 시
		CPlayer::Render();//부모클래스 범위지정자 함수
	}
private:
	int m_iA;
};


int main()
{
	//함수 오버라이딩
	CPlayer tPlayer;
	CUnit tUnit;
	CPlayer* pPlayer = &tPlayer;
	pPlayer->Render();

	C_Obj* pObj = &tPlayer; //묵시적으로 up 캐스팅(형변환). 원래는 자식인데 들어갈 때 부모형식으로 형변환이 일어나서 들어가는 것
	pObj->Render(); //virtual을 안 붙이면 해당 객체 포인터 기준의 함수가 호출되는데 virtual을 붙이면 실제 객체인 자식의 오버라이딩 된 함수를 호출한다.
	//pObj->LevelUp(); // 불가. 업 캐스팅이 되면 자식이 가진 멤버 함수를 호출 불가. 그래서 자식으로 다운 캐스팅 하여 함수 호출해야 한다.
	//캐스팅 종류
	//c++ 4가지를 지원. static_cast<>(), dynamic_cast<>(). reinterpret_cast<>(). const_cast<>();
	CPlayer* pTest = static_cast<CPlayer*>(pObj); //pObj를 CPlayer의 포인터 타입으로 형변환 해준다. 
	//이미 자식에서 부모로 업 캐스팅 된 상태에서 다시 자식으로 다운 캐스팅 하는 게 안전한 캐스팅.
	//static_cast 는 상속 관계를 따진다. 상속 관계 아니면 에러난다.ex) int* ptr = static_cast<int*>(new float) c스타일과 차이점.= (int*) 와 같이 앞에 걍 형식 붙여버리는 거. 
	//static_cast는 상곡의 유무를 따진다. 논리적 형변환. 컴파일 시점에서 잘못된 형변환을 막아줄 수 있고 c스타일보다 안전하다. 안전성 검사 때문에 대신 느리다. 뭘 쓰든 합당한 걸 써도 되는데 이유와 통일성을 가지자.
	//논리형이긴 한데 조금 멍청한 논리긴 하다.
	//문제는 같은 부모를 상속 받는다면 다운 캐스팅 단계에서 전혀 다른 클래스로 해버려도 에러가 발생하지 않는다는 점이다. 클래스 a에서 클래스 b로 스테틱 형변환을 시도하면 에러가 나는데
	//부모 a를 상속 받는 자식 a,b 클래스가 있을 때 자식 a가 자식 b로 형변환될 수 있는 문제가 발생한다. 자식 b의 함수를 쓸 수 있는데 자식 b만의 멤버 변수를 쓴다고 하면 자식 a에는 그게 없기에 에러가 터진다.
	//이런 문제때문에 상속 관계의 객체 포인터를 형변환할 때는 dynamic_cast를 쓰는 편이다.
	//스테틱 캐스트는 보통 자료형의 형변환을 할 때 쓰인다. ex) int a = static_cast<int>(3.14f);
	//참고로 바꾸고자 하는 값 자체가 바뀌는 게 아니고 해당 값을 형변환해서 대입만 해준다는 뜻이다.
	int ptr = static_cast<int>(3.14f); //자료형끼리는 형변환 가능. 하지만 포인터 형변환은 금지. 다만 상속관계라면 허용.
	pTest->Render();
	pTest->LevelUp();
	C_Obj* pObj2 = &tUnit;
	pObj2->Render();
    return 0;


	//virtual 가상 함수를 사용하게 되면 virtual 포인터와 테이블이 잡힌다. 
	//virtual 함수를 가진 class는 버쥬얼 테이블을 가리키는 포인터를 가지게 된다. 이후 가상 함수를 사용할 때 실객체의 함수를 불러오기 위해 가상 테이블에 접근하게 된다.
	//가상 함수를 쓰면 일반 함수보다 느린데 이건 바인딩과 관련된 부분이다.
	//정적 바인딩과 동적 바인딩 // 거의 대부분 정적과 동적이냐는 컴파일 시점이냐 런타임 시점이냐는 점이다.
	//정적 바인딩-컴파일 시점에서 어떠한 변수의 성격과 성질이 결정되는 것 ex) int i = 0; i의 타입은 int로 정해진다.
	//동적 바인딩-런타임 시점의 어떠한 변수의 성격과 성질이 결정되는 것. ex) int* ptr = new int; 런타임 시점에서 new int의 크기를 결정지어주겠다.
	//이와 마찬가지로 일반 함수는 컴파일 단계에서 결정지어진다. 하지만 버츄얼 함수는 컴파일 단계에서 실행 함수를 보류하고 런타임 시점에서 어떤 함수를 실행할 지 결정짓는다.
	//그래서 일반 함수보다 실행 속도가 느리다.

	//가상함수 왜 쓰냐
	//예를 들어 플레이어와 몬스터가 쥰내게 많다고 했을 때 각각 다 행동을 한다 했을 때 객체를 일일이 생성하고 호출하기는 불편하다.

	C_Obj* pObj3 = new CPlayer; //
	delete pObj3;
	pObj3 = nullptr; 
	//이 경우 문제가 발생하는 게 부모 객체 포인터 기준으로 delete가 되므로 부모 소멸자만 호출되고 자식 소멸자가 호출되지 않는 문제가 발생.
	//이러한 경우 반드시 가상 소멸자 virtual ~C_Obj();를 만들어 자식 소멸자가 호출되도록 정의를 해줘야 한다.
	//그런데 이러한 이유가 필요 없을 경우, 굳이 자식 소멸자를 호출하거나 그런 케이스 거나 부모 객체 포인터가 있는 게 아니라면. 아니면 virtual을 빼주자. 메모리 낭비다.

	//순수 가상 함수
	//virtual 타입 함수명() = 0; 으로 만들어 줄 수 있다. 
	//이것은 나를 상속 받는 모든 클래스가 반드시 이 것을 가지고, 재정의를 해줬으면 싶다 할 때 사용한다.(overriding)
	//그냥 가상 함수와 달리 자식이 없으면 에러가 발생한다.
	//근데 순수 가상 함수를 하나라도 선언하면 해당 클래스는 추상 클래스가 되어 객체화 시킬 수가 없다. 객체 포인터는 사용 가능.
	//순수 가상 함수를 선언하는 순간부터 불완전한 클래스(추상 클래스)가 된다. 애초에 부모 클래스는 미완성의 개념이 크기에 대부분 물려주는 용도이다.
	//그래서 보통은 객체 포인터 목적으로 쓰인다.
}



/* 
1/3 = (t-1/3)/2 .  => 2 = 3t-3   t= 5/3
1/2 = 1/3 + 75km -t  => t = 1/6 +75  -> 10-1/6 = 75  => 75 x 2/3 즉 50키로미터

 

*/