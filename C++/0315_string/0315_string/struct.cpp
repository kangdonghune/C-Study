#include <iostream>
#include <string>
using namespace std;



//구조체 정의
typedef struct alignas(16) tagTest //alignas(16) 같이 몇 바이트를 기준으로 할당할 지 크기를 지정해줄 수도 있다. 보편적으론 외부에다가 정의를 한다. main내부에 해도 문제는 없다.
{
	double d;
	int a;
	short b;
	string s;
} Test; //예정에는 c타입에서 struct 스트럭트 이름 변수이름; 으로 선언해야했기에 struct를 제외하기 위해 다음과 같이 재정의해서 편이성을 가졌다.
		//아직도 이런 방식으로 쓰는 사람도 있으니 알아는 두자. 지금은 이렇게 안 써도 무관하다.
typedef int _INT;//자료형을 재정의하는 문법. int라는 자료형에 _INT 라는 이름을 추가로 지어준 것. 따라서 _INT를 통해서도 int타입을 만들 수 있다.
// 자료형을 재정의할 필요가 있을까? A: 이유는 해당 자료형의 크기가 바뀔 수 있기 때문이다.
// ex) 경험치 단위를 short으로 해놨는데 경험치량이 커져서 부담이 될 경우 int로 바꿔야 할 경우 재정의명은 그대로 두고 앞에 타입만 바꿔주면 해결이 쉽다.
// 이 같은 점을 고려해야 유지보수의 편이성이 생긴다. 이런 경우가 많다보니 잘 고려하자.

typedef struct TagStudent
{
	char Name[32];
	int StudentNum;
} STUDENT; // 구조체는 전부 대문자로 적어 기본자료형과 구별이 쉽도록 한다.

//void InsertStudent(STUDENT* pStudent)
//{
//	cout << "이름: ";
//	cin >> (*pStudent).Name; //현재 오류는 우선순위 문제 때문이다. *역참조보다 . dot 연산자가 우선순위가 높아서 발생하는 문제이니 우선순위를 정리해주자.
//	cin >> pStudent->Name;//화살표 연산자. 위의 코드와 의미는 같다. 구조체 포인터일 경우 멤버에 접근하려면 ->를 활용하자.
//}

void InsertStudent(STUDENT Student[]) //배열이라 명시했을 뿐 배열이 아닌 값을 넘겨줘도 된다. STUDENT* student 와 같은 의미. 주소를 받아오면 그 주소부터가 0번 인덱스가 됨.
{
	cout << "이름: ";
	cin >> Student->Name; // -> 은 (*Student). 을 요약한 것. 포인터의 경우에만 사용.
}
//구조체 안에 나 자신을 담는 경우.

typedef struct TAG
{
	int a;
	TAG* t; 
	//이런 식의 구조면 크기를 가늠할 수 가 없다. 이 자체는 문제가 된다. 그래서 비슷하게 만들어주자. 무한적으로 안으로 파고들어간다.
	//크기를 강제한다. 바로 포인터로. 이러면 바로 4바이트의 크기가 되버린다.
	//단 내부적으로 구조체를 사용할 경우 상위에 해당 스트럭트가 위치해야 컴파일 에러가 발생하지 않는다.
}TAG;

int main()
{
	//구조체 - 사용자 정의 자료형에 해당이 된다.
	//구조체 선인과 동시에 초기화;
	tagTest tag = { 3,2,1 }; //초기화 자체는 배열과 비슷하다. 좌측부터 구조체 내부 멤버변수 순서대로 들어간다.
	cout << tag.a << endl; //해당 구조체의 멤버변수를 호출할 때는 .dot 연산자를 활용한다.
	cout << tag.b << endl;
	//cout << tag.c << endl;

	//구조체의 크기.
	cout << sizeof(tag) << endl;//구조체의 크기는 멤버변수 중 가장 크기가 큰 타입형의 크기를 기준으로 할당크기가 정해진다.
	//즉 int가 가장 큰 타입이먄 4바이트 크기의 할당 범위를 받고 그 안에 멤버 변수를 넣는다.
	//문제는 4바이트 중 2바이트를 short이 쓰면 다음 오는 int의 4바이트틀 넣을 크기가 부족하기에 그 공간을 비워두고 새로 크기를 할당 받아 넣는다.
	//그렇기에 실제 데이터 크기는 10바이트더라도 12바이트의 크기를 메모리에서 할당받는다.
	//안 쓰고 버리는 빈 공간을 패딩 바이트라고 한다. 이 같은 방식을 취하는 건 컴퓨터의 연산 편이성을 고려한 것이다.
	//이렇기 때문에 구조체를 설계할 때는 이러한 점을 고려해서 멤버변수 순서를 배치해야 한다.

	_INT a = 0; 

	STUDENT tStudents[3] = { {"단비", 80} , {"금비", 75}, {"은비", 99} };
	STUDENT tStudent = { "단비", 80 };
	STUDENT* pStudent;
	cout << tStudents << endl;
	STUDENT* pStudents[3] = { tStudents }; //구조체 하나로는 자체적인 반환이 없지만 배열로 만들면 배열 특성상 주소값을 반환한다.
	cout << pStudents[0]->Name << endl; //여기선 포인터 변수이기에 -> 사용가능하다.
	//구조체의 포인터 형식을 갖는 배열일지라도 하나씩 뜯어보면 어렵지 않다.
	//하나씩 뜯은 다음에 화살표 연산자로 접근하면 된다.
	
	InsertStudent(&tStudents[1]);
	cout << tStudents[1].Name << endl;

	TAG t[3] = {};
	cout << sizeof(t) << endl;
	cout << t << endl;
	//구조체는 매개변수로 넘겨줄 떄 포인터를 쓰는 경우가 많다.
	//단순히 call by value로 넘겨주게 되면 메모리를 많이 차지하게 된다. 하지만 포인터로 넘겨주면 4바이트로 메모리를 아낄 수 있다.
	//굳이 안 써도 되는데도 쓰는 이유다.
	//-> 는 구조체의 포인터형식일 때.  . 닷연산자는 구조체의 멤버에 접근할 때.
	//구조체를 쓰면 좋은 점은 함수의 반환값에 1개씩 밖에 안되던 것이 구조체로 묶어서 보내면 여러개를 보낼 수 있다.
}


//전에 만든 과제들을 구조체형식으로만들어 인자 간소화.