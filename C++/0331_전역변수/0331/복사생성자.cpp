#include "stdafx.h"
//얕은 복사=쉘로우shlallow copy 카피 깊은 복사=딥카피 deep copy
//얕은 복사는 같은 주소를 바라본다는 문제가 있다.
//이는 포인터 멤버 변수,동적할당된 변수가 있을 때 뎅글링 포인터가 발생할 수 있다는 문제가 있다.
//딥카피는 바라보는 대상을 동적할당으로 새로 해주고 거기에 값을 복사해서 바라본다.
//이를 하면 뎅글링 포인터가 방지.

class CCopy
{
public:
	
	CCopy()
	{
		cout << "생성자 호출" << endl;
	}

	~CCopy()
	{
		cout << "소멸자 호출" << endl;
	}

	//따로 선언안하고 디폴트 복사 생성자를 하면 모든 멤버 값을 그대로 다 복사해 넣어준다.
	CCopy(CCopy& rhs) //레퍼런스로 안하고 그냥 CCopy 같은 객체로 받게 되면 무한히 호출하게 되기 때문에 막아놨다.포인터는 되나? 포인터는 단순히 주소값을 담는 변수지 그 자체가 객체가 될 수 없다. 단순 인자다. 안 된다.
		:m_iA(rhs.m_iA)
	{
		//얕은 복사. 값을 그대로 복사한다. 일반적인 변수값을 복사할 때는 문제가 없는데 포인터 멤버 변수를 복사하게 되면 문제가 된다. 복사대상이 된 원본 클래스가 소멸하며 해당 포인터 멤버 변수가 할당 해제되면 뎅글링 포인터가 되버린다.
		cout << "레퍼런스 복사 생성자 호출" << endl;
	}

	CCopy(const CCopy& rhs)
	{
		m_pA = new int;
		*m_pA = *rhs.m_pA; //별도의 주소에 값만 공유.
	}

	CCopy(CCopy* rhs) //레퍼런스로 안하고 그냥 CCopy 같은 객체로 받게 되면 무한히 호출하게 되기 때문에 막아놨다.포인터는 되나? 포인터는 단순히 주소값을 담는 변수지 그 자체가 객체가 될 수 없다. 단순 인자다. 안 된다.
		: m_iA(rhs->m_iA)
	{
		cout << "포인터 복사 생성자 호출" << endl;
	}

	void Render()
	{
		cout << m_iA << endl;
	}

	void SetRender(int some)
	{
		m_iA = some;
	}
private:
	int m_iA;
	int* m_pA;

};

void Print(CCopy tCopy)//지역 변수로 임시로 CCopy 클래스 생성. 이때 매개변수로 받은 클래스를 복사하여 생성하기에 복사 생성자 호출
{
	tCopy.Render();
}//함수 종료 시 임시로 생성되었던 클래스 소멸하며 기본 소멸자 호출

int main() 
{
	//복사 생성자
	//클래스가 자동으로 생성하고 호출해주는 4가지. 생성자 소멸자 그리고 복사 생성자
	//CCopy tCopy;
	//tCopy.SetRender(10);
	//CCopy tCopy2 = tCopy; // CCopy tCopy2(tCopy);  가지고 있는 데이터를 값 복사 방식으로 가진다.
	//CCopy tCopy3 = &tCopy; 포인터로 매개변수 넘기는 경우
	//tCopy2.Render();


	//복사 생성자가 호출되는 시점.
	//1.객체 생성 시 객체에 인자로 같은 객체를 넘겨주는 경우
	//2.함수 호출 시 call by value 형식으로 값을 넘겨주는 경우.
	//3.종료 시 call by value 형식으로 값을 반환하는 경우00


	//friend .사용을 자제하는 문법 중 하나.
	//사용을 자제하는 문법 삼대장 goto friend 다중 상속
	//클래스 내부에서 friend class ClassName; 같이 해주면
	//친구가 된 ClassName에서 해당 클래스의 private 멤버를 수정할 수 있게 된다. friend 가 된 특정 외부에 한해서 내부 접근을 허락한다는 의미.
	//그래서 해당 문법은 은닉성을 침해하기 때문에 사용을 자제한다.
	//또 이건 일방향적이기에 친구를 건 클래스는 친구요청을 받은 클래스의 멤버에 접근할 수 가 없다.

	//상속
	//어떠한 클래스가 있을 때 공통으로 사용하는 데이터가 있다라면 상위에 클래스에서 데이터 또는 데이터를 다루는 함수를 물려주는 것
	//물려주는 쪽을 부모클래스 상위클래스, 슈퍼클래스, base클래스 라 부르고 물려받는 쪽을 하위 클래스, 파생클래스, 자식 클래스 derived클래스 등으로 부른다.
	//상위로 올라가면 올라갈 수록 추상화 및 일반화가 일어나며 하위로 내려가면 갈 수록 세분화 및 특수화가 일어난다.

}