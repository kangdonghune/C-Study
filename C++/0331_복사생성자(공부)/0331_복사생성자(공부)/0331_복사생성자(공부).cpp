// 0331_복사생성자(공부).cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"

class CTest
{
public:
	CTest()
		:m_iA(0)
	{
		m_pA = nullptr;
		cout << "기본 생성자 호출" << endl;
	}
	~CTest() 
	{	 
		delete m_pA; 
		//복사 생성자는 m_pA를 동적할당 받아서 초기화 해야하는데 m_pA는 동적할당을 받지 않았다.
		//포인터 멤버 변수가 있는 경우 항상 생성자에서 nullptr 초기화 후 동적 할당을 해준다?

		m_pA = nullptr;
		cout << "기본 소멸자 호출" << endl;
	}

	explicit CTest(int some, int* ptr)
		:m_iA(some) //생성보다 이니셜라이져가 앞서 있다.?
	{
		m_pA = new int;
		*m_pA = *ptr;


		cout << "오버로딩 생성자 호출" << endl;
	}
	CTest(CTest* pTest)
	{
		cout << "이게 호출되면 기본 복사 생성자로 인지" << endl;
		//포인터는 객체가 아니고 주소 자료형 타입일 뿐. 객체가 될 수 없다. 따라서 기본 복사 생성자로 인식이 안 된다.
	}
	//기본 복사 생성자를 정의 안하면 디폴트로 자동 생성하는데 그 경우 복사 대상의 멤버값을 그대로 복사하고자 하는 클래스에 복사해준다.
	//CTest(CTest& rhs) //클래스를 복사해서 넣을려고 하는데 객체로 받아야 하는데 포인터는 객체가 아니고 클래스를 그냥 받으면 에러가 난다. 따라서 레퍼런스 활용.
	//	:m_iA(rhs.m_iA),m_pA(rhs.m_pA)
	//{
	//	cout << "기본 복사 생성자 호출" << endl;
	//}
	CTest(const CTest& rhs)  //const가 타입 앞에 붙으면 참조주소 변경 가능 값 변경 불가 변수명 앞에 붙으면 값 변경 불가 주소 변경 가능
	{
		cout << "깊은 복사 생성자 호출" << endl;
		m_iA = rhs.m_iA;
		m_pA = new int; // 동적 할당.
		*m_pA = *rhs.m_pA;//괄호 없어도 역참조 연산자가 . 닷 연산자보다 우선순위 밀린다. 이렇게 하면 복사된 클래스 포인터 멤버 변수가 가진 주소값하고 기존 클래스 포인터 멤버 변수가 가진 주소값은 다르지만 주소값이 가리키는 내용물은 같게 된다.
	}
	/*CTest(CTest CTest) //이 경우는 문제가 되는 게 매개변수는 지역변수로 생성되는데 매개변수로 클래스를 받으면 클래스 생성을 위해 다시 복사 생성자를 호출하며 무한반복된다. 이 때문에 아예 막아둠.
	{

	}*/

public:
	void Render()
	{
		cout << m_iA << endl;
	}

public:
	int m_iA;
	int* m_pA;
};

int main()
{
	int a = 10;
	CTest CT;
	CT.Render();
	CTest CT2(a,&a);
	CT2.Render();
	cout << CT.m_pA << endl;
	cout << CT2.m_pA  << endl;
	CTest CT3 = CT2;
	CT3.Render(); 

	cout << CT.m_pA << endl;
	cout << CT2.m_pA  << endl;
	cout << CT3.m_pA << endl; //둘이 같은 주소를 가지고 있다. 둘 중 한 클래스라도 값을 변경하면 다른 클래스도 멤버 값이 변경됨.
	
	cout << *CT2.m_pA << endl;
	cout << *CT3.m_pA << endl;

	//복사 생성자로 값을 그대로 복사해오는 것을 얕은 복사, shallow copy라고 한다.
	//일반 멤버 변수의 경우 크게 문제될 것이 없는데 문제가 발생하는 부분은 포인터 변수나 동적 할당된 멤버 변수의 값을 그대로 복사해올 경우다.
	//클래스 복사해서 새로운 클래스를 생성할 경우 서로 다른 클래스가 같은 주소를 바라본다. 여기까진 큰 문제가 아닌데 어느 한 클래스에서 포인터 주소로 접근해 값을 변경하거나 소멸하며 할당을 해제해버리는 경우
	//아직 살아있는 다른 클래스의 값에 영향을 준다는 문제가 있고 추가적으로 남아있던 클래스가 소멸하며 할당 해제를 시도하는 상황에서 뎅글링 포인터 문제가 발생한다.(이미 같은 곳을 바라보던 클래스가 delete해버렸기 때문에 중복 delete)
	//이를 방지하기 위해 deepcopy 깊은 복사를 쓴다.

	//깊은 복사
	//깊은 복사는 값을 복사해 쓴다는 개념 자체는 같지만 새로운 메모리를 동적할당을 받은 후 그 메모리에 기존 클래스의 값만 복사해 담는 방식이다.
	//이렇게 하면 포인터 변수를 복사해도 두 포인터 주소가 가진 값 자체는 같지만 포인터 주소 자체는 다르게 되어 한 쪽이 주소로 접근해 값을 변경해도 다른 쪽에 영향이 없고
	//마찬가지로 동적할당 받은 것 역시 서로 메모리 주소가 다르기에 문제가 없다.



	return 0;

}

